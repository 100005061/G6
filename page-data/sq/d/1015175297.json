{"data":{"site":{"siteMetadata":{"playground":{"extraLib":"declare module '@antv/g6'{\n          import { AnimateCfg } from '@antv/g-base/lib/types';\r\nimport { BBox } from '@antv/g-base/lib/types';\r\nimport Canvas from '@antv/g-canvas/lib/canvas';\r\nimport EventEmitter from '@antv/event-emitter';\r\nimport GraphEvent from '@antv/g-base/lib/event/graph-event';\r\nimport Group from '@antv/g-canvas/lib/group';\r\nimport { IGroup } from '@antv/g-base/lib/interfaces';\r\nimport { IGroup as IGroup_2 } from '@antv/g-base';\r\nimport { Point } from '@antv/g-base/lib/types';\r\nimport ShapeBase from '@antv/g-canvas/lib/shape/base';\r\n\r\ndeclare interface ArrowConfig {\r\n    d?: number;\r\n    path?: string;\r\n    stroke?: string;\r\n    fill?: string;\r\n}\r\n\r\ndeclare interface BubblesetCfg {\r\n    morphBuffer?: number;\r\n    pixelGroupSize?: number;\r\n    maxMarchingIterations?: number;\r\n    maxRoutingIterations?: number;\r\n    nodeR0?: number;\r\n    nodeR1?: number;\r\n    edgeR0?: number;\r\n    edgeR1?: number;\r\n    nodeInfluenceFactor?: number;\r\n    negativeNodeInfluenceFactor?: number;\r\n    edgeInfluenceFactor?: number;\r\n    memberInfluenceFactor?: number;\r\n    nonMemberInfluenceFactor?: number;\r\n}\r\n\r\ndeclare interface ComboConfig extends ModelConfig {\r\n    id: string;\r\n    parentId?: string;\r\n    children?: ComboTree[];\r\n    depth?: number;\r\n    padding?: number | number[];\r\n    collapseIcon?: Partial<{\r\n        show: boolean;\r\n        collapseSymbol: any;\r\n        expandSymbol: any;\r\n        r: number;\r\n        lineWidth: number;\r\n        stroke: string;\r\n        offsetX: number;\r\n        offsetY: number;\r\n    }>;\r\n}\r\n\r\ndeclare interface ComboTree {\r\n    id: string;\r\n    label?: string | LabelStyle;\r\n    children?: ComboTree[];\r\n    depth?: number;\r\n    parentId?: string;\r\n    removed?: boolean;\r\n    itemType?: 'node' | 'combo';\r\n    [key: string]: unknown;\r\n}\r\n\r\ndeclare type DataUrlType = 'image/png' | 'image/jpeg' | 'image/webp' | 'image/bmp';\r\n\r\ndeclare const _default: {\r\n    Graph: typeof Graph;\r\n};\r\nexport default _default;\r\n\r\ndeclare interface EdgeConfig extends ModelConfig {\r\n    id?: string;\r\n    source?: string;\r\n    target?: string;\r\n    sourceNode?: Node_2;\r\n    targetNode?: Node_2;\r\n    startPoint?: IPoint;\r\n    endPoint?: IPoint;\r\n    controlPoints?: IPoint[];\r\n    curveOffset?: number | number[];\r\n    loopCfg?: LoopConfig;\r\n    labelCfg?: ILabelConfig;\r\n}\r\n\r\ndeclare class Graph extends EventEmitter implements IGraph {\r\n    private animating;\r\n    private cfg;\r\n    destroyed: boolean;\r\n    private undoStack;\r\n    private redoStack;\r\n    constructor(cfg: GraphOptions);\r\n    private init;\r\n    private initCanvas;\r\n    private initPlugin;\r\n    private initGroups;\r\n    getDefaultCfg(): Partial<PrivateGraphOption>;\r\n    /**\r\n     * 将值设置到 this.cfg 变量上面\r\n     * @param key 键 或 对象值\r\n     * @param val 值\r\n     */\r\n    set<T = any>(key: string | object, val?: T): Graph;\r\n    /**\r\n     * 获取 this.cfg 中的值\r\n     * @param key 键\r\n     */\r\n    get(key: string): any;\r\n    /**\r\n     * 获取 graph 的根图形分组\r\n     * @return 根 group\r\n     */\r\n    getGroup(): any;\r\n    /**\r\n     * 获取 graph 的 DOM 容器\r\n     * @return DOM 容器\r\n     */\r\n    getContainer(): any;\r\n    /**\r\n     * 获取 graph 的最小缩放比例\r\n     * @return minZoom\r\n     */\r\n    getMinZoom(): any;\r\n    /**\r\n     * 设置 graph 的最小缩放比例\r\n     * @return minZoom\r\n     */\r\n    setMinZoom(ratio: number): Graph;\r\n    /**\r\n     * 获取 graph 的最大缩放比例\r\n     * @param maxZoom\r\n     */\r\n    getMaxZoom(): any;\r\n    /**\r\n     * 设置 graph 的最大缩放比例\r\n     * @param maxZoom\r\n     */\r\n    setMaxZoom(ratio: number): Graph;\r\n    /**\r\n     * 获取 graph 的宽度\r\n     * @return width\r\n     */\r\n    getWidth(): any;\r\n    /**\r\n     * 获取 graph 的高度\r\n     * @return width\r\n     */\r\n    getHeight(): any;\r\n    /**\r\n     * 清理元素多个状态\r\n     * @param {string|Item} item 元素id或元素实例\r\n     * @param {string[]} states 状态\r\n     */\r\n    clearItemStates(item: Item | string, states?: string[] | string): void;\r\n    /**\r\n     * 设置各个节点样式，以及在各种状态下节点 keyShape 的样式。\r\n     * 若是自定义节点切在各种状态下\r\n     * graph.node(node => {\r\n     *  return {\r\n     *    type: 'rect',\r\n     *    label: node.id,\r\n     *    style: { fill: '#666' },\r\n     *    stateStyles: {\r\n     *       selected: { fill: 'blue' },\r\n     *       custom: { fill: 'green' }\r\n     *     }\r\n     *   }\r\n     * });\r\n     * @param {function} nodeFn 指定每个节点样式\r\n     */\r\n    node(nodeFn: (config: NodeConfig) => Partial<NodeConfig>): void;\r\n    /**\r\n     * 设置各个边样式\r\n     * @param {function} edgeFn 指定每个边的样式,用法同 node\r\n     */\r\n    edge(edgeFn: (config: EdgeConfig) => Partial<EdgeConfig>): void;\r\n    /**\r\n     * 设置各个 combo 的配置\r\n     * @param comboFn\r\n     */\r\n    combo(comboFn: (config: ComboConfig) => Partial<ComboConfig>): void;\r\n    /**\r\n     * 根据 ID 查询图元素实例\r\n     * @param id 图元素 ID\r\n     */\r\n    findById(id: string): Item;\r\n    /**\r\n     * 根据对应规则查找单个元素\r\n     * @param {ITEM_TYPE} type 元素类型(node | edge | group)\r\n     * @param {(item: T, index: number) => T} fn 指定规则\r\n     * @return {T} 元素实例\r\n     */\r\n    find<T extends Item>(type: ITEM_TYPE, fn: (item: T, index?: number) => boolean): T | undefined;\r\n    /**\r\n     * 查找所有满足规则的元素\r\n     * @param {string} type 元素类型(node|edge)\r\n     * @param {string} fn 指定规则\r\n     * @return {array} 元素实例\r\n     */\r\n    findAll<T extends Item>(type: ITEM_TYPE, fn: (item: T, index?: number) => boolean): T[];\r\n    /**\r\n     * 查找所有处于指定状态的元素\r\n     * @param {string} type 元素类型(node|edge)\r\n     * @param {string} state 状态\r\n     * @return {object} 元素实例\r\n     */\r\n    findAllByState<T extends Item>(type: ITEM_TYPE, state: string): T[];\r\n    /**\r\n     * 平移画布\r\n     * @param dx 水平方向位移\r\n     * @param dy 垂直方向位移\r\n     */\r\n    translate(dx: number, dy: number): void;\r\n    /**\r\n     * 平移画布到某点\r\n     * @param {number} x 水平坐标\r\n     * @param {number} y 垂直坐标\r\n     */\r\n    moveTo(x: number, y: number): void;\r\n    /**\r\n     * 调整视口适应视图\r\n     * @param {object} padding 四周围边距\r\n     */\r\n    fitView(padding?: Padding): void;\r\n    /**\r\n     * 调整视口适应视图，不缩放，仅将图 bbox 中心对齐到画布中心\r\n     */\r\n    fitCenter(): void;\r\n    /**\r\n     * 新增行为\r\n     * @param {string | ModeOption | ModeType[]} behaviors 添加的行为\r\n     * @param {string | string[]} modes 添加到对应的模式\r\n     * @return {Graph} Graph\r\n     */\r\n    addBehaviors(behaviors: string | ModeOption | ModeType[], modes: string | string[]): Graph;\r\n    /**\r\n     * 移除行为\r\n     * @param {string | ModeOption | ModeType[]} behaviors 移除的行为\r\n     * @param {string | string[]} modes 从指定的模式中移除\r\n     * @return {Graph} Graph\r\n     */\r\n    removeBehaviors(behaviors: string | ModeOption | ModeType[], modes: string | string[]): Graph;\r\n    /**\r\n     * 伸缩窗口\r\n     * @param ratio 伸缩比例\r\n     * @param center 以center的x, y坐标为中心缩放\r\n     */\r\n    zoom(ratio: number, center?: Point): void;\r\n    /**\r\n     * 伸缩视口到一固定比例\r\n     * @param {number} toRatio 伸缩比例\r\n     * @param {Point} center 以center的x, y坐标为中心缩放\r\n     */\r\n    zoomTo(toRatio: number, center?: Point): void;\r\n    /**\r\n     * 将元素移动到视口中心\r\n     * @param {Item} item 指定元素\r\n     * @param {boolean} animate 是否带有动画地移动\r\n     * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\r\n     */\r\n    focusItem(item: Item | string, animate?: boolean, animateCfg?: GraphAnimateConfig): void;\r\n    /**\r\n     * 自动重绘\r\n     * @internal 仅供内部更新机制调用，外部根据需求调用 render 或 paint 接口\r\n     */\r\n    autoPaint(): void;\r\n    /**\r\n     * 仅画布重新绘制\r\n     */\r\n    paint(): void;\r\n    /**\r\n     * 将屏幕坐标转换为视口坐标\r\n     * @param {number} clientX 屏幕x坐标\r\n     * @param {number} clientY 屏幕y坐标\r\n     * @return {Point} 视口坐标\r\n     */\r\n    getPointByClient(clientX: number, clientY: number): Point;\r\n    /**\r\n     * 将视口坐标转换为屏幕坐标\r\n     * @param {number} x 视口x坐标\r\n     * @param {number} y 视口y坐标\r\n     * @return {Point} 视口坐标\r\n     */\r\n    getClientByPoint(x: number, y: number): Point;\r\n    /**\r\n     * 将画布坐标转换为视口坐标\r\n     * @param {number} canvasX 画布 x 坐标\r\n     * @param {number} canvasY 画布 y 坐标\r\n     * @return {object} 视口坐标\r\n     */\r\n    getPointByCanvas(canvasX: number, canvasY: number): Point;\r\n    /**\r\n     * 将视口坐标转换为画布坐标\r\n     * @param {number} x 视口 x 坐标\r\n     * @param {number} y 视口 y 坐标\r\n     * @return {object} 画布坐标\r\n     */\r\n    getCanvasByPoint(x: number, y: number): Point;\r\n    /**\r\n     * 显示元素\r\n     * @param {Item} item 指定元素\r\n     * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n     */\r\n    showItem(item: Item | string, stack?: boolean): void;\r\n    /**\r\n     * 隐藏元素\r\n     * @param {Item} item 指定元素\r\n     * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n     */\r\n    hideItem(item: Item | string, stack?: boolean): void;\r\n    /**\r\n     * 刷新元素\r\n     * @param {string|object} item 元素id或元素实例\r\n     */\r\n    refreshItem(item: Item | string): void;\r\n    /**\r\n     * 设置是否在更新/刷新后自动重绘\r\n     * @param {boolean} auto 自动重绘\r\n     */\r\n    setAutoPaint(auto: boolean): void;\r\n    /**\r\n     * 删除元素\r\n     * @param {Item} item 元素id或元素实例\r\n     * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n     */\r\n    remove(item: Item | string, stack?: boolean): void;\r\n    /**\r\n     * 删除元素\r\n     * @param {Item} item 元素id或元素实例\r\n     * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n     */\r\n    removeItem(item: Item | string, stack?: boolean): void;\r\n    /**\r\n     * 新增元素 或 节点分组\r\n     * @param {ITEM_TYPE} type 元素类型(node | edge | group)\r\n     * @param {ModelConfig} model 元素数据模型\r\n     * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n     * @return {Item} 元素实例\r\n     */\r\n    addItem(type: ITEM_TYPE, model: ModelConfig, stack?: boolean): any;\r\n    /**\r\n     * 新增元素 或 节点分组\r\n     * @param {ITEM_TYPE} type 元素类型(node | edge | group)\r\n     * @param {ModelConfig} model 元素数据模型\r\n     * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n     * @return {Item} 元素实例\r\n     */\r\n    add(type: ITEM_TYPE, model: ModelConfig, stack?: boolean): Item;\r\n    /**\r\n     * 更新元素\r\n     * @param {Item} item 元素id或元素实例\r\n     * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\r\n     */\r\n    updateItem(item: Item | string, cfg: Partial<NodeConfig> | EdgeConfig, stack?: boolean): void;\r\n    /**\r\n     * 更新元素\r\n     * @param {Item} item 元素id或元素实例\r\n     * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\r\n     * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n     */\r\n    update(item: Item | string, cfg: Partial<NodeConfig> | EdgeConfig, stack?: boolean): void;\r\n    /**\r\n     * 设置元素状态\r\n     * @param {Item} item 元素id或元素实例\r\n     * @param {string} state 状态名称\r\n     * @param {string | boolean} value 是否启用状态 或 状态值\r\n     */\r\n    setItemState(item: Item | string, state: string, value: string | boolean): void;\r\n    /**\r\n     * 将指定状态的优先级提升为最高优先级\r\n     * @param {Item} item 元素id或元素实例\r\n     * @param state 状态名称\r\n     */\r\n    priorityState(item: Item | string, state: string): void;\r\n    /**\r\n     * 设置视图初始化数据\r\n     * @param {GraphData} data 初始化数据\r\n     */\r\n    data(data?: GraphData | TreeGraphData): void;\r\n    /**\r\n     * 根据data接口的数据渲染视图\r\n     */\r\n    render(): void;\r\n    /**\r\n     * 接收数据进行渲染\r\n     * @Param {Object} data 初始化数据\r\n     */\r\n    read(data: GraphData): void;\r\n    private diffItems;\r\n    /**\r\n     * 更改源数据，根据新数据重新渲染视图\r\n     * @param {GraphData | TreeGraphData} data 源数据\r\n     * @param {boolean} 是否入栈，默认为true\r\n     * @return {object} this\r\n     */\r\n    changeData(data?: GraphData | TreeGraphData, stack?: boolean): Graph;\r\n    /**\r\n     * 私有方法，在 render 和 changeData 的时候批量添加数据中所有平铺的 combos\r\n     * @param {ComboConfig[]} combos 平铺的 combos 数据\r\n     */\r\n    private addCombos;\r\n    /**\r\n     * 根据已经存在的节点或 combo 创建新的 combo\r\n     * @param combo combo ID 或 Combo 配置\r\n     * @param children 添加到 Combo 中的元素，包括节点和 combo\r\n     */\r\n    createCombo(combo: string | ComboConfig, children: string[]): void;\r\n    /**\r\n     * 解散 combo\r\n     * @param {String | INode | ICombo} combo 需要被解散的 Combo item 或 id\r\n     */\r\n    uncombo(combo: string | ICombo): void;\r\n    /**\r\n     * 根据节点的 bbox 更新所有 combos 的绘制，包括 combos 的位置和范围\r\n     */\r\n    updateCombos(): void;\r\n    /**\r\n     * 根据节点的 bbox 更新 combo 及其祖先 combos 的绘制，包括 combos 的位置和范围\r\n     * @param {String | ICombo} combo 需要被更新的 Combo 或 id，若指定，则该 Combo 及所有祖先 Combod 都会被更新\r\n     */\r\n    updateCombo(combo: string | ICombo): void;\r\n    /**\r\n     * 更新树结构，例如移动子树等\r\n     * @param {String | INode | ICombo} item 需要被更新的 Combo 或 节点 id\r\n     * @param {string | undefined} parentId 新的父 combo id，undefined 代表没有父 combo\r\n     */\r\n    updateComboTree(item: string | INode | ICombo, parentId?: string | undefined): void;\r\n    /**\r\n     * 根据数据渲染群组\r\n     * @param {GraphData} data 渲染图的数据\r\n     * @param {string} groupType group类型\r\n     */\r\n    renderCustomGroup(data: GraphData, groupType: string): void;\r\n    /**\r\n     * 导出图数据\r\n     * @return {object} data\r\n     */\r\n    save(): TreeGraphData | GraphData;\r\n    /**\r\n     * 改变画布大小\r\n     * @param  {number} width  画布宽度\r\n     * @param  {number} height 画布高度\r\n     * @return {object} this\r\n     */\r\n    changeSize(width: number, height: number): Graph;\r\n    /**\r\n     * 当源数据在外部发生变更时，根据新数据刷新视图。但是不刷新节点位置\r\n     */\r\n    refresh(): void;\r\n    /**\r\n     * 获取当前图中所有节点的item实例\r\n     * @return {INode} item数组\r\n     */\r\n    getNodes(): INode[];\r\n    /**\r\n     * 获取当前图中所有边的item实例\r\n     * @return {IEdge} item数组\r\n     */\r\n    getEdges(): IEdge[];\r\n    /**\r\n     * 获取图中所有的 combo 实例\r\n     */\r\n    getCombos(): ICombo[];\r\n    /**\r\n     * 获取指定 Combo 中所有的节点\r\n     * @param comboId combo ID\r\n     */\r\n    getComboChildren(combo: string | ICombo): {\r\n        nodes: INode[];\r\n        combos: ICombo[];\r\n    };\r\n    /**\r\n     * 根据 graph 上的 animateCfg 进行视图中节点位置动画接口\r\n     */\r\n    positionsAnimate(): void;\r\n    /**\r\n     * 当节点位置在外部发生改变时，刷新所有节点位置，重计算边\r\n     */\r\n    refreshPositions(): void;\r\n    stopAnimate(): void;\r\n    isAnimating(): boolean;\r\n    /**\r\n     * 获取当前视口伸缩比例\r\n     * @return {number} 比例\r\n     */\r\n    getZoom(): number;\r\n    /**\r\n     * 获取当前的行为模式\r\n     * @return {string} 当前行为模式\r\n     */\r\n    getCurrentMode(): string;\r\n    /**\r\n     * 切换行为模式\r\n     * @param {string} mode 指定模式\r\n     * @return {object} this\r\n     */\r\n    setMode(mode: string): Graph;\r\n    /**\r\n     * 清除画布元素\r\n     * @return {object} this\r\n     */\r\n    clear(): Graph;\r\n    /**\r\n     * 返回可见区域的图的 dataUrl，用于生成图片\r\n     * @param {String} type 图片类型，可选值：\"image/png\" | \"image/jpeg\" | \"image/webp\" | \"image/bmp\"\r\n     * @param {string} backgroundColor 图片背景色\r\n     * @return {string} 图片 dataURL\r\n     */\r\n    toDataURL(type?: DataUrlType, backgroundColor?: string): string;\r\n    /**\r\n     * 返回整个图（包括超出可见区域的部分）的 dataUrl，用于生成图片\r\n     * @param {Function} callback 异步生成 dataUrl 完成后的回调函数，在这里处理生成的 dataUrl 字符串\r\n     * @param {String} type 图片类型，可选值：\"image/png\" | \"image/jpeg\" | \"image/webp\" | \"image/bmp\"\r\n     * @param {Object} imageConfig 图片配置项，包括背景色和上下左右的 padding\r\n     */\r\n    toFullDataURL(callback: (res: string) => any, type?: DataUrlType, imageConfig?: {\r\n        backgroundColor?: string;\r\n        padding?: number | number[];\r\n    }): void;\r\n    /**\r\n     * 导出包含全图的图片\r\n     * @param {String} name 图片的名称\r\n     * @param {String} type 图片类型，可选值：\"image/png\" | \"image/jpeg\" | \"image/webp\" | \"image/bmp\"\r\n     * @param {Object} imageConfig 图片配置项，包括背景色和上下左右的 padding\r\n     */\r\n    downloadFullImage(name?: string, type?: DataUrlType, imageConfig?: {\r\n        backgroundColor?: string;\r\n        padding?: number | number[];\r\n    }): void;\r\n    /**\r\n     * 画布导出图片，图片仅包含画布可见区域部分内容\r\n     * @param {String} name 图片的名称\r\n     * @param {String} type 图片类型，可选值：\"image/png\" | \"image/jpeg\" | \"image/webp\" | \"image/bmp\"\r\n     * @param {string} backgroundColor 图片背景色\r\n     */\r\n    downloadImage(name?: string, type?: DataUrlType, backgroundColor?: string): void;\r\n    private dataURLToImage;\r\n    /**\r\n     * 更换布局配置项\r\n     * @param {object} cfg 新布局配置项\r\n     * 若 cfg 含有 type 字段或为 String 类型，且与现有布局方法不同，则更换布局\r\n     * 若 cfg 不包括 type ，则保持原有布局方法，仅更新布局配置项\r\n     */\r\n    updateLayout(cfg: any): void;\r\n    /**\r\n     * 重新以当前示例中配置的属性进行一次布局\r\n     */\r\n    layout(): void;\r\n    /**\r\n     * 收起指定的 combo\r\n     * @param {string | ICombo} combo combo ID 或 combo item\r\n     */\r\n    collapseCombo(combo: string | ICombo): void;\r\n    /**\r\n     * 展开指定的 combo\r\n     * @param {string | ICombo} combo combo ID 或 combo item\r\n     */\r\n    expandCombo(combo: string | ICombo): void;\r\n    collapseExpandCombo(combo: string | ICombo): void;\r\n    /**\r\n     * 收起分组\r\n     * @param {string} groupId 分组ID\r\n     */\r\n    collapseGroup(groupId: string): void;\r\n    /**\r\n     * 展开分组\r\n     * @param {string} groupId 分组ID\r\n     */\r\n    expandGroup(groupId: string): void;\r\n    /**\r\n     * 添加插件\r\n     * @param {object} plugin 插件实例\r\n     */\r\n    addPlugin(plugin: PluginBase): void;\r\n    /**\r\n     * 添加插件\r\n     * @param {object} plugin 插件实例\r\n     */\r\n    removePlugin(plugin: PluginBase): void;\r\n    /**\r\n     * 根据 comboTree 结构整理 Combo 相关的图形绘制层级，包括 Combo 本身、节点、边\r\n     * @param {GraphData} data 数据\r\n     */\r\n    private sortCombos;\r\n    /**\r\n     * 获取节点所有的邻居节点\r\n     *\r\n     * @param {(string | INode)} node 节点 ID 或实例\r\n     * @returns {INode[]}\r\n     * @memberof IGraph\r\n     */\r\n    getNeighbors(node: string | INode, type?: 'source' | 'target' | undefined): INode[];\r\n    /**\r\n     * 获取 node 的度数\r\n     *\r\n     * @param {(string | INode)} node 节点 ID 或实例\r\n     * @param {('in' | 'out' | 'total' | 'all' | undefined)} 度数类型，in 入度，out 出度，total 总度数，all 返回三种类型度数的对象\r\n     * @returns {Number | Object} 该节点的度数\r\n     * @memberof IGraph\r\n     */\r\n    getNodeDegree(node: string | INode, type?: 'in' | 'out' | 'total' | 'all' | undefined): Number | Object;\r\n    getUndoStack(): Stack;\r\n    getRedoStack(): Stack;\r\n    /**\r\n     * 获取 undo 和 redo 栈的数据\r\n     */\r\n    getStackData(): {\r\n        undoStack: any[];\r\n        redoStack: any[];\r\n    };\r\n    /**\r\n     * 清空 undo stack & redo stack\r\n     */\r\n    clearStack(): void;\r\n    /**\r\n     * 将操作类型和操作数据入栈\r\n     * @param action 操作类型\r\n     * @param data 入栈的数据\r\n     * @param stackType 栈的类型\r\n     */\r\n    pushStack(action?: string, data?: unknown, stackType?: string): void;\r\n    /**\r\n     * 获取邻接矩阵\r\n     *\r\n     * @param {boolean} cache 是否使用缓存的\r\n     * @param {boolean} directed 是否是有向图，默认取 graph.directed\r\n     * @returns {Matrix} 邻接矩阵\r\n     * @memberof IGraph\r\n     */\r\n    getAdjMatrix(cache?: boolean, directed?: boolean): Number | Object;\r\n    /**\r\n     * 获取最短路径矩阵\r\n     *\r\n     * @param {boolean} cache 是否使用缓存的\r\n     * @param {boolean} directed 是否是有向图，默认取 graph.directed\r\n     * @returns {Matrix} 最短路径矩阵\r\n     * @memberof IGraph\r\n     */\r\n    getShortestPathMatrix(cache?: boolean, directed?: boolean): Number | Object;\r\n    /**\r\n     * 销毁画布\r\n     */\r\n    destroy(): void;\r\n    createHull(cfg: HullCfg): any;\r\n    getHulls(): any;\r\n    getHullById(hullId: string): any;\r\n    removeHull(hull: Hull | string): void;\r\n}\r\n\r\ndeclare interface GraphAnimateConfig extends AnimateCfg {\r\n    /**\r\n     * 回调函数，用于自定义节点运动路径。\r\n     */\r\n    onFrame?: (item: Item, ratio: number, data?: GraphData, originAttrs?: ShapeStyle) => unknown;\r\n}\r\n\r\ndeclare interface GraphData {\r\n    nodes?: NodeConfig[];\r\n    edges?: EdgeConfig[];\r\n    groups?: GroupConfig[];\r\n    combos?: ComboConfig[];\r\n}\r\n\r\ndeclare interface GraphOptions {\r\n    /**\r\n     * 图的 DOM 容器，可以传入该 DOM 的 id 或者直接传入容器的 HTML 节点对象\r\n     */\r\n    container: string | HTMLElement;\r\n    /**\r\n     * 指定画布宽度，单位为 'px'\r\n     */\r\n    width: number;\r\n    /**\r\n     * 指定画布高度，单位为 'px'\r\n     */\r\n    height: number;\r\n    /**\r\n     * renderer canvas or svg\r\n     */\r\n    renderer?: string;\r\n    fitView?: boolean;\r\n    fitCenter?: boolean;\r\n    layout?: LayoutConfig;\r\n    /**\r\n     * 图适应画布时，指定四周的留白。\r\n     * 可以是一个值, 例如：fitViewPadding: 20\r\n     * 也可以是一个数组，例如：fitViewPadding: [20, 40, 50,20]\r\n     * 当指定一个值时，四边的边距都相等，当指定数组时，数组内数值依次对应 上，右，下，左四边的边距。\r\n     */\r\n    fitViewPadding?: Padding;\r\n    /**\r\n     * 各种元素是否在一个分组内，决定节点和边的层级问题，默认情况下所有的节点在一个分组中，所有的边在一个分组中，当这个参数为 false 时，节点和边的层级根据生成的顺序确定。\r\n     * 默认值：true\r\n     */\r\n    groupByTypes?: boolean;\r\n    directed?: boolean;\r\n    groupStyle?: {\r\n        style?: {\r\n            [key: string]: ShapeStyle;\r\n        };\r\n    };\r\n    /**\r\n     * 当图中元素更新，或视口变换时，是否自动重绘。建议在批量操作节点时关闭，以提高性能，完成批量操作后再打开，参见后面的 setAutoPaint() 方法。\r\n     * 默认值：true\r\n     */\r\n    autoPaint?: boolean;\r\n    /**\r\n     * 设置画布的模式。详情可见G6中的Mode文档。\r\n     */\r\n    modes?: Modes;\r\n    /**\r\n     * 默认状态下节点的配置，比如 type, size, color。会被写入的 data 覆盖。\r\n     */\r\n    defaultNode?: Partial<{\r\n        shape: string;\r\n        type: string;\r\n        size: number | number[];\r\n        color: string;\r\n    }> & ModelStyle;\r\n    /**\r\n     * 默认状态下边的配置，比如 type, size, color。会被写入的 data 覆盖。\r\n     */\r\n    defaultEdge?: Partial<{\r\n        shape: string;\r\n        type: string;\r\n        size: number | number[];\r\n        color: string;\r\n    }> & ModelStyle;\r\n    /**\r\n     * Combo 默认配置\r\n     */\r\n    defaultCombo?: Partial<{\r\n        type: string;\r\n        size: number | number[];\r\n        color: string;\r\n    }> & ModelStyle;\r\n    nodeStateStyles?: StateStyles;\r\n    edgeStateStyles?: StateStyles;\r\n    comboStateStyles?: StateStyles;\r\n    /**\r\n     * 向 graph 注册插件。插件机制请见：plugin\r\n     */\r\n    plugins?: any[];\r\n    /**\r\n     * 是否启用全局动画。\r\n     */\r\n    animate?: boolean;\r\n    /**\r\n     * 动画配置项，仅在animate为true时有效。\r\n     */\r\n    animateCfg?: GraphAnimateConfig;\r\n    /**\r\n     * 最小缩放比例\r\n     * 默认值 0.2\r\n     */\r\n    minZoom?: number;\r\n    /**\r\n     * 最大缩放比例\r\n     * 默认值 10\r\n     */\r\n    maxZoom?: number;\r\n    groupType?: string;\r\n    /**\r\n     * Edge 是否连接到节点中间\r\n     */\r\n    linkCenter?: boolean;\r\n    /**\r\n     * 是否启用 stack，即是否开启 redo & undo 功能\r\n     */\r\n    enabledStack?: boolean;\r\n    /**\r\n     * redo & undo 最大步数, 只有当 enabledStack 为 true 时才起作用\r\n     */\r\n    maxStep?: number;\r\n    /**\r\n     * 存储图上的 tooltip dom，方便销毁\r\n     */\r\n    tooltips?: [];\r\n}\r\n\r\ndeclare interface GroupConfig {\r\n    id: string;\r\n    parentId?: string;\r\n    [key: string]: string | ModelStyle | undefined;\r\n}\r\n\r\n/**\r\n * 用于包裹内部的成员的轮廓。\r\n * convex hull(凸包)：http://geomalgorithms.com/a10-_hull-1.html#Monotone%20Chain\r\n * bubble: 使用 bubbleset算法，refer: http://vialab.science.uoit.ca/wp-content/papercite-data/pdf/col2009c.pdf\r\n * 通过配置 padding 可以调节包裹轮廓对节点的松紧程度\r\n */\r\ndeclare class Hull {\r\n    id: string;\r\n    graph: IGraph;\r\n    cfg: any;\r\n    path: any[][];\r\n    group: IGroup_2;\r\n    members: Item[];\r\n    nonMembers: Item[];\r\n    padding: number;\r\n    bubbleCfg: Partial<BubblesetCfg>;\r\n    type: string;\r\n    constructor(graph: IGraph, cfg: HullCfg);\r\n    getDefaultCfg(): HullCfg;\r\n    setPadding(): void;\r\n    setType(): void;\r\n    calcPath(members: Item[], nonMembers: Item[]): any;\r\n    render(): void;\r\n    /**\r\n     * 增加hull的成员，同时如果该成员原先在nonMembers中，则从nonMembers中去掉\r\n     * @param item 节点实例\r\n     * @return boolean 添加成功返回 true，否则返回 false\r\n     */\r\n    addMember(item: Item | string): boolean;\r\n    /**\r\n     * 增加hull需要排除的节点，同时如果该成员原先在members中，则从members中去掉\r\n     * @param item 节点实例\r\n     * @return boolean 添加成功返回 true，否则返回 false\r\n     */\r\n    addNonMember(item: Item | string): boolean;\r\n    /**\r\n     * 移除hull中的成员\r\n     * @param node 节点实例\r\n     * @return boolean 移除成功返回 true，否则返回 false\r\n     */\r\n    removeMember(item: Item | string): boolean;\r\n    /**\r\n     * @param node 节点实例\r\n     * @return boolean 移除成功返回 true，否则返回 false\r\n     */\r\n    removeNonMember(item: Item | string): boolean;\r\n    updateData(members: Item[] | string[], nonMembers: string[] | Item[]): void;\r\n    updateStyle(cfg: HullCfg['style']): void;\r\n    updateCfg(cfg: Partial<HullCfg>): void;\r\n    /**\r\n     * 判断是否在hull内部\r\n     * @param item\r\n     */\r\n    contain(item: Item | string): boolean;\r\n    destroy(): void;\r\n}\r\n\r\ndeclare interface HullCfg {\r\n    id: string;\r\n    members?: Item[] | string[];\r\n    nonMembers?: Item[] | string[];\r\n    group?: IGroup_2;\r\n    type?: string;\r\n    padding?: number;\r\n    style?: {\r\n        fill?: string;\r\n        stroke?: string;\r\n        opacity?: number;\r\n    };\r\n    bubbleCfg?: BubblesetCfg;\r\n}\r\n\r\ndeclare interface IBBox extends BBox {\r\n    centerX?: number;\r\n    centerY?: number;\r\n    [key: string]: number | undefined;\r\n}\r\n\r\ndeclare interface ICombo extends INode {\r\n    /**\r\n     * 获取 Combo 中所有的子元素，包括 Combo、Node 及 Edge\r\n     */\r\n    getChildren: () => {\r\n        nodes: INode[];\r\n        combos: ICombo[];\r\n    };\r\n    /**\r\n     * 获取 Combo 中所有节点\r\n     */\r\n    getNodes: () => INode[];\r\n    /**\r\n     * 获取 Combo 中所有子 combo\r\n     */\r\n    getCombos: () => INode[];\r\n    /**\r\n     * 向 Combo 中增加 combo\r\n     * @param item 节点或 combo 的 Item 实例\r\n     * @return boolean 添加成功返回 true，否则返回 false\r\n     */\r\n    addChild: (item: INode | ICombo) => boolean;\r\n    /**\r\n     * 向 Combo 中增加 combo\r\n     * @param combo Combo 实例\r\n     * @return boolean 添加成功返回 true，否则返回 false\r\n     */\r\n    addCombo: (combo: ICombo) => boolean;\r\n    /**\r\n     * 向 Combo 中添加节点\r\n     * @param node 节点实例\r\n     * @return boolean 添加成功返回 true，否则返回 false\r\n     */\r\n    addNode: (node: string | INode) => boolean;\r\n    /**\r\n     * 从 Combo 中移除子元素\r\n     * @param item Combo 或 Node 实例\r\n     * @return boolean 添加成功返回 true，否则返回 false\r\n     */\r\n    removeChild: (item: ICombo | INode) => boolean;\r\n    /**\r\n     * 从 Combo 中移除指定的 combo\r\n     * @param combo Combo 实例\r\n     * @return boolean 移除成功返回 true，否则返回 false\r\n     */\r\n    removeCombo: (combo: ICombo) => boolean;\r\n    /**\r\n     * 向 Combo 中移除指定的节点\r\n     * @param node 节点实例\r\n     * @return boolean 移除成功返回 true，否则返回 false\r\n     */\r\n    removeNode: (node: string | INode) => boolean;\r\n}\r\n\r\ndeclare interface IEdge extends IItemBase {\r\n    setSource(source: INode | ICombo): void;\r\n    setTarget(target: INode | ICombo): void;\r\n    getSource(): INode | ICombo;\r\n    getTarget(): INode | ICombo;\r\n}\r\n\r\ndeclare interface IG6GraphEvent extends GraphEvent {\r\n    item: Item | null;\r\n    canvasX: number;\r\n    canvasY: number;\r\n    wheelDelta: number;\r\n    detail: number;\r\n    key?: string;\r\n    target: Item & Canvas;\r\n}\r\n\r\ndeclare interface IGraph extends EventEmitter {\r\n    getDefaultCfg(): Partial<GraphOptions>;\r\n    get<T = any>(key: string): T;\r\n    set<T = any>(key: string | object, value?: T): Graph;\r\n    findById(id: string): Item;\r\n    translate(dx: number, dy: number): void;\r\n    zoom(ratio: number, center?: Point): void;\r\n    /**\r\n     * 将屏幕坐标转换为视口坐标\r\n     * @param {number} clientX 屏幕 x 坐标\r\n     * @param {number} clientY 屏幕 y 坐标\r\n     * @return {Point} 视口坐标\r\n     */\r\n    getPointByClient(clientX: number, clientY: number): Point;\r\n    /**\r\n     * 将视口坐标转换为屏幕坐标\r\n     * @param {number} x 视口x坐标\r\n     * @param {number} y 视口y坐标\r\n     * @return {object} 视口坐标\r\n     */\r\n    getClientByPoint(x: number, y: number): Point;\r\n    /**\r\n     * 将画布坐标转换为视口坐标\r\n     * @param {number} canvasX 画布 x 坐标\r\n     * @param {number} canvasY 画布 y 坐标\r\n     * @return {Point} 视口坐标\r\n     */\r\n    getPointByCanvas(canvasX: number, canvasY: number): Point;\r\n    /**\r\n     * 将视口坐标转换为画布坐标\r\n     * @param {number} x 视口 x 坐标\r\n     * @param {number} y 视口 y 坐标\r\n     * @return {Point} 画布坐标\r\n     */\r\n    getCanvasByPoint(x: number, y: number): Point;\r\n    /**\r\n     * 设置是否在更新/刷新后自动重绘\r\n     * @param {boolean} auto 自动重绘\r\n     */\r\n    setAutoPaint(auto: boolean): void;\r\n    /**\r\n     * 显示元素\r\n     * @param {Item} item 指定元素\r\n     * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n     */\r\n    showItem(item: Item | string, stack?: boolean): void;\r\n    /**\r\n     * 隐藏元素\r\n     * @param {Item} item 指定元素\r\n     * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n     */\r\n    hideItem(item: Item | string, stack?: boolean): void;\r\n    /**\r\n     * 仅画布重新绘制\r\n     */\r\n    paint(): void;\r\n    /**\r\n     * 自动重绘\r\n     */\r\n    autoPaint(): void;\r\n    /**\r\n     * 刷新元素\r\n     * @param {Item} item 元素id或元素实例\r\n     */\r\n    refreshItem(item: Item | string): void;\r\n    /**\r\n     * 将元素移动到视口中心\r\n     * @param {Item} item 指定元素\r\n     * @param {boolean} animate 是否带有动画地移动\r\n     * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\r\n     */\r\n    focusItem(item: Item | string, animate?: boolean, animateCfg?: GraphAnimateConfig): void;\r\n    /**\r\n     * 调整视口适应视图\r\n     * @param {Padding} padding 四周围边距\r\n     */\r\n    fitView(padding?: Padding): void;\r\n    /**\r\n     * 调整视口适应视图，不缩放，仅将图 bbox 中心对齐到画布中心\r\n     */\r\n    fitCenter(): void;\r\n    /**\r\n     * 伸缩视口到一固定比例\r\n     * @param {number} toRatio 伸缩比例\r\n     * @param {Point} center 以center的x, y坐标为中心缩放\r\n     */\r\n    zoomTo(toRatio: number, center?: Point): void;\r\n    /**\r\n     * 删除元素\r\n     * @param {Item} item 元素id或元素实例\r\n     * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n     */\r\n    removeItem(item: Item | string, stack?: boolean): void;\r\n    /**\r\n     * 删除元素\r\n     * @param {Item} item 元素id或元素实例\r\n     * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n     */\r\n    remove(item: Item | string, stack?: boolean): void;\r\n    /**\r\n     * 新增元素 或 节点分组\r\n     * @param {string} type 元素类型(node | edge | group)\r\n     * @param {ModelConfig} model 元素数据模型\r\n     * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n     * @return {Item} 元素实例\r\n     */\r\n    addItem(type: ITEM_TYPE, model: ModelConfig, stack?: boolean): Item;\r\n    add(type: ITEM_TYPE, model: ModelConfig, stack?: boolean): Item;\r\n    /**\r\n     * 更新元素\r\n     * @param {Item} item 元素id或元素实例\r\n     * @param {EdgeConfig | NodeConfig} cfg 需要更新的数据\r\n     * @param {boolean} stack 本次操作是否入栈，默认为 true\r\n     */\r\n    updateItem(item: Item | string, cfg: Partial<NodeConfig> | EdgeConfig, stack?: boolean): void;\r\n    update(item: Item | string, cfg: Partial<NodeConfig> | EdgeConfig, stack?: boolean): void;\r\n    /**\r\n     * 更新 Combo 结构，例如移动子树等\r\n     * @param {string | INode | ICombo} item 需要被更新的 Combo 或 节点 id\r\n     * @param {string | undefined} parentId 新的父 combo id，undefined 代表没有父 combo\r\n     */\r\n    updateComboTree(item: string | INode | ICombo, parentId?: string | undefined): void;\r\n    /**\r\n     * 解散 combo\r\n     * @param {String | ICombo} item 需要被解散的 Combo item 或 id\r\n     */\r\n    uncombo(item: string | ICombo): void;\r\n    /**\r\n     * 根据已经存在的节点或 combo 创建新的 combo\r\n     * @param combo combo ID 或 Combo 配置\r\n     * @param elements 添加到 Combo 中的元素，包括节点和 combo\r\n     */\r\n    createCombo(combo: string | ComboConfig, elements: string[]): void;\r\n    /**\r\n     * 设置元素状态\r\n     * @param {Item} item 元素id或元素实例\r\n     * @param {string} state 状态名称\r\n     * @param {boolean} value 是否启用状态或状态值\r\n     */\r\n    setItemState(item: Item | string, state: string, value: string | boolean): void;\r\n    /**\r\n     * 将指定状态的优先级提升为最高优先级\r\n     * @param {Item} item 元素id或元素实例\r\n     * @param state 状态名称\r\n     */\r\n    priorityState(item: Item | string, state: string): void;\r\n    /**\r\n     * 设置视图初始化数据\r\n     * @param {GraphData} data 初始化数据\r\n     */\r\n    data(data?: GraphData | TreeGraphData): void;\r\n    /**\r\n     * 当源数据在外部发生变更时，根据新数据刷新视图。但是不刷新节点位置\r\n     */\r\n    refresh(): void;\r\n    /**\r\n     * 根据 graph 上的 animateCfg 进行视图中节点位置动画接口\r\n     */\r\n    positionsAnimate(): void;\r\n    /**\r\n     * 当节点位置在外部发生改变时，刷新所有节点位置，重计算边\r\n     */\r\n    refreshPositions(): void;\r\n    /**\r\n     * 根据data接口的数据渲染视图\r\n     */\r\n    render(): void;\r\n    /**\r\n     * 获取当前图中所有节点的item实例\r\n     */\r\n    getNodes(): INode[];\r\n    /**\r\n     * 获取当前图中所有边的item实例\r\n     */\r\n    getEdges(): IEdge[];\r\n    /**\r\n     * 获取当前图中所有 combo 的实例\r\n     */\r\n    getCombos(): ICombo[];\r\n    /**\r\n     * 获取节点所有的邻居节点，有向图中效果同无向图\r\n     *\r\n     * @param {(string | INode)} node 节点 ID 或实例\r\n     * @returns {INode[]}\r\n     * @memberof IGraph\r\n     */\r\n    getNeighbors(node: string | INode, type?: 'source' | 'target' | undefined): INode[];\r\n    /**\r\n     * 获取指定 combo 中所有的节点\r\n     * @param comboId Combo ID 或 combo 实例\r\n     */\r\n    getComboChildren(combo: string | ICombo): {\r\n        nodes: INode[];\r\n        combos: ICombo[];\r\n    };\r\n    /**\r\n     * 获取当前视口伸缩比例\r\n     * @return {number} 比例\r\n     */\r\n    getZoom(): number;\r\n    /**\r\n     * 获取当前的行为模式\r\n     */\r\n    getCurrentMode(): string;\r\n    /**\r\n     * 切换行为模式\r\n     * @param {string} mode 指定模式\r\n     */\r\n    setMode(mode: string): Graph;\r\n    isAnimating(): boolean;\r\n    stopAnimate(): void;\r\n    /**\r\n     * 新增行为\r\n     * @param {string | ModeOption | ModeType[]} behaviors 添加的行为\r\n     * @param {string | string[]} modes 添加到对应的模式\r\n     * @return {Graph} Graph\r\n     */\r\n    addBehaviors(behaviors: string | ModeOption | ModeType[], modes: string | string[]): Graph;\r\n    /**\r\n     * 移除行为\r\n     * @param {string | ModeOption | ModeType[]} behaviors 移除的行为\r\n     * @param {string | string[]} modes 从指定的模式中移除\r\n     * @return {Graph} Graph\r\n     */\r\n    removeBehaviors(behaviors: string | ModeOption | ModeType[], modes: string | string[]): Graph;\r\n    /**\r\n     * 清除画布元素\r\n     */\r\n    clear(): Graph;\r\n    /**\r\n     * 根据数据渲染群组\r\n     * @param {GraphData} data 渲染图的数据\r\n     * @param {string} groupType group类型\r\n     */\r\n    renderCustomGroup(data: GraphData, groupType: string): void;\r\n    /**\r\n     * 接收数据进行渲染\r\n     * @Param {GraphData} data 初始化数据\r\n     */\r\n    read(data: GraphData): void;\r\n    /**\r\n     * 更改源数据，根据新数据重新渲染视图\r\n     * @param {GraphData | TreeGraphData} data 源数据\r\n     * @param {boolean} 是否入栈，默认为true\r\n     * @return {object} this\r\n     */\r\n    changeData(data?: GraphData | TreeGraphData, stack?: boolean): Graph;\r\n    /**\r\n     * 导出图数据\r\n     * @return {GraphData} data\r\n     */\r\n    save(): TreeGraphData | GraphData;\r\n    /**\r\n     * 改变画布大小\r\n     * @param  {number} width  画布宽度\r\n     * @param  {number} height 画布高度\r\n     * @return {Graph} this\r\n     */\r\n    changeSize(width: number, height: number): Graph;\r\n    /**\r\n     * 清理元素多个状态\r\n     * @param {string|Item} item 元素id或元素实例\r\n     * @param {string | string[]} states 状态\r\n     */\r\n    clearItemStates(item: Item | string, states?: string | string[]): void;\r\n    /**\r\n     * 设置各个节点样式，以及在各种状态下节点 keyShape 的样式。\r\n     * 若是自定义节点切在各种状态下\r\n     * graph.node(node => {\r\n     *  return {\r\n     *    {\r\n     *       type: 'rect',\r\n     *      label: node.id,\r\n     *       style: { fill: '#666' },\r\n     *      stateStyles: {\r\n     *         selected: { fill: 'blue' },\r\n     *         custom: { fill: 'green' }\r\n     *       }\r\n     *     }\r\n     *  }\r\n     * });\r\n     * @param {function} nodeFn 指定每个节点样式\r\n     */\r\n    node(nodeFn: (config: NodeConfig) => Partial<NodeConfig>): void;\r\n    /**\r\n     * 设置各个边样式\r\n     * @param {function} edgeFn 指定每个边的样式,用法同 node\r\n     */\r\n    edge(edgeFn: (config: EdgeConfig) => Partial<EdgeConfig>): void;\r\n    /**\r\n     * 设置每个 combo 的配置\r\n     * @param comboFn 指定每个 combo 的配置\r\n     */\r\n    combo(comboFn: (config: ComboConfig) => Partial<ComboConfig>): void;\r\n    /**\r\n     * 平移画布到某点\r\n     * @param {number} x 水平坐标\r\n     * @param {number} y 垂直坐标\r\n     */\r\n    moveTo(x: number, y: number): void;\r\n    /**\r\n     * 根据对应规则查找单个元素\r\n     * @param {ITEM_TYPE} type 元素类型(node | edge | group)\r\n     * @param {(item: T, index: number) => T} fn 指定规则\r\n     * @return {T} 元素实例\r\n     */\r\n    find<T extends Item>(type: ITEM_TYPE, fn: (item: T, index?: number) => boolean): T | undefined;\r\n    /**\r\n     * 查找所有满足规则的元素\r\n     * @param {string} type 元素类型(node|edge)\r\n     * @param {string} fn 指定规则\r\n     * @return {array} 元素实例\r\n     */\r\n    findAll<T extends Item>(type: ITEM_TYPE, fn: (item: T, index?: number) => boolean): T[];\r\n    /**\r\n     * 查找所有处于指定状态的元素\r\n     * @param {string} type 元素类型(node|edge)\r\n     * @param {string} state z状态\r\n     * @return {object} 元素实例\r\n     */\r\n    findAllByState<T extends Item>(type: ITEM_TYPE, state: string): T[];\r\n    /**\r\n     * 返回图表的 dataUrl 用于生成图片\r\n     */\r\n    toDataURL(): string;\r\n    /**\r\n     * 画布导出图片\r\n     * @param {String} name 图片的名称\r\n     */\r\n    downloadImage(name: string): void;\r\n    /**\r\n     * 更换布局配置项\r\n     * @param {object} cfg 新布局配置项\r\n     * 若 cfg 含有 type 字段或为 String 类型，且与现有布局方法不同，则更换布局\r\n     * 若 cfg 不包括 type ，则保持原有布局方法，仅更新布局配置项\r\n     */\r\n    updateLayout(cfg: LayoutConfig): void;\r\n    /**\r\n     * 重新以当前示例中配置的属性进行一次布局\r\n     */\r\n    layout(): void;\r\n    /**\r\n     * 添加插件\r\n     * @param {object} plugin 插件实例\r\n     */\r\n    addPlugin(plugin: PluginBase): void;\r\n    /**\r\n     * 添加插件\r\n     * @param {object} plugin 插件实例\r\n     */\r\n    removePlugin(plugin: PluginBase): void;\r\n    /**\r\n     * 收起指定的 Combo\r\n     * @param comboId combo ID 或 combo 实例\r\n     */\r\n    collapseCombo(combo: string | ICombo): void;\r\n    /**\r\n     * 展开指定的 Combo\r\n     * @param combo combo ID 或 combo 实例\r\n     */\r\n    expandCombo(combo: string | ICombo): void;\r\n    /**\r\n     * 展开或收缩指定的 Combo\r\n     * @param comboId combo ID 或 combo 实例\r\n     */\r\n    collapseExpandCombo(combo: string | ICombo): void;\r\n    /**\r\n     * 收起分组\r\n     * @param {string} groupId 分组ID\r\n     */\r\n    collapseGroup(groupId: string): void;\r\n    /**\r\n     * 展开分组\r\n     * @param {string} groupId 分组ID\r\n     */\r\n    expandGroup(groupId: string): void;\r\n    /**\r\n     * 根据节点的 bbox 更新所有 combos 的绘制，包括 combos 的位置和范围\r\n     */\r\n    updateCombos(): void;\r\n    /**\r\n     * 获取 undo stack\r\n     */\r\n    getUndoStack(): Stack;\r\n    /**\r\n     * 获取 redo stack\r\n     */\r\n    getRedoStack(): Stack;\r\n    /**\r\n     * 获取 undo 和 redo 栈的数据\r\n     */\r\n    getStackData(): {\r\n        undoStack: StackData[];\r\n        redoStack: StackData[];\r\n    };\r\n    /**\r\n     * 清空 undo stack & redo stack\r\n     */\r\n    clearStack(): void;\r\n    /**\r\n     * 将操作类型和操作数据入栈\r\n     * @param action 操作类型\r\n     * @param data 入栈的数据\r\n     * @param stackType 入栈的类型\r\n     */\r\n    pushStack(action?: string, data?: unknown, stackType?: 'redo' | 'undo'): void;\r\n    /**\r\n     * 根据节点的 bbox 更新 combo 及其祖先 combos 的绘制，包括 combos 的位置和范围\r\n     * @param combo 需要更新的 combo\r\n     */\r\n    updateCombo(combo: string | ICombo): void;\r\n    /**\r\n     * 销毁画布\r\n     */\r\n    destroy(): void;\r\n}\r\n\r\ndeclare interface IGroupBBox {\r\n    [key: string]: BBox;\r\n}\r\n\r\ndeclare interface IItemBase {\r\n    _cfg: IItemBaseConfig | null;\r\n    destroyed: boolean;\r\n    isItem(): boolean;\r\n    getShapeStyleByName(name?: string): ShapeStyle | void;\r\n    /**\r\n     * 获取当前元素的所有状态\r\n     * @return {Array} 元素的所有状态\r\n     */\r\n    getStates(): string[];\r\n    /**\r\n     * 当前元素是否处于某状态\r\n     * @param {String} state 状态名\r\n     * @return {Boolean} 是否处于某状态\r\n     */\r\n    hasState(state: string): boolean;\r\n    getStateStyle(state: string): ShapeStyle;\r\n    getOriginStyle(): ShapeStyle;\r\n    getCurrentStatesStyle(): ShapeStyle;\r\n    /**\r\n     * 更改元素状态， visible 不属于这个范畴\r\n     * @internal 仅提供内部类 graph 使用\r\n     * @param {String} state 状态名\r\n     * @param {Boolean} value 节点状态值\r\n     */\r\n    setState(state: string, value: string | boolean): void;\r\n    clearStates(states?: string | string[]): void;\r\n    /**\r\n     * 节点的图形容器\r\n     * @return {G.Group} 图形容器\r\n     */\r\n    getContainer(): Group;\r\n    /**\r\n     * 节点的关键形状，用于计算节点大小，连线截距等\r\n     * @return {IShapeBase} 关键形状\r\n     */\r\n    getKeyShape(): IShapeBase;\r\n    /**\r\n     * 节点 / 边 / Combo 的数据模型\r\n     * @return {Object} 数据模型\r\n     */\r\n    getModel(): NodeConfig | EdgeConfig | ComboConfig;\r\n    /**\r\n     * 节点类型\r\n     * @return {string} 节点的类型\r\n     */\r\n    getType(): ITEM_TYPE;\r\n    /**\r\n     * 获取 Item 的ID\r\n     */\r\n    getID(): string;\r\n    getShapeCfg(model: ModelConfig): ModelConfig;\r\n    /**\r\n     * 刷新一般用于处理几种情况\r\n     * 1. item model 在外部被改变\r\n     * 2. 边的节点位置发生改变，需要重新计算边\r\n     *\r\n     * 因为数据从外部被修改无法判断一些属性是否被修改，直接走位置和 shape 的更新\r\n     */\r\n    refresh(): void;\r\n    /**\r\n     * 将更新应用到 model 上，刷新属性\r\n     * @internal 仅提供给 Graph 使用，外部直接调用 graph.update 接口\r\n     * @param  {Object} cfg       配置项，可以是增量信息\r\n     */\r\n    update(cfg: ModelConfig): void;\r\n    /**\r\n     * 更新元素内容，样式\r\n     */\r\n    updateShape(): void;\r\n    /**\r\n     * 更新位置，避免整体重绘\r\n     * @param {object} cfg 待更新数据\r\n     */\r\n    updatePosition(cfg: Point): void;\r\n    /**\r\n     * 绘制元素\r\n     */\r\n    draw(): void;\r\n    /**\r\n     * 获取 item 的包围盒，这个包围盒是相对于 item 自己，不会将 matrix 计算在内\r\n     */\r\n    getBBox(): IBBox;\r\n    /**\r\n     * 获取 item 相对于画布的包围盒，会将从顶层到当前元素的 matrix 都计算在内\r\n     */\r\n    getCanvasBBox(): IBBox;\r\n    /**\r\n     * 将元素放到最前面\r\n     */\r\n    toFront(): void;\r\n    /**\r\n     * 将元素放到最后面\r\n     */\r\n    toBack(): void;\r\n    /**\r\n     * 显示元素\r\n     */\r\n    show(): void;\r\n    /**\r\n     * 隐藏元素\r\n     */\r\n    hide(): void;\r\n    /**\r\n     * 更改是否显示\r\n     * @param  {Boolean} visible 是否显示\r\n     */\r\n    changeVisibility(visible: boolean): void;\r\n    /**\r\n     * 是否捕获及触发该元素的交互事件\r\n     * @param {Boolean} enable 标识位\r\n     */\r\n    enableCapture(enable: boolean): void;\r\n    isVisible(): boolean;\r\n    isOnlyMove(cfg: ModelConfig): boolean;\r\n    get<T = any>(key: string): T;\r\n    set<T = any>(key: string, value: T): void;\r\n    destroy(): void;\r\n}\r\n\r\ndeclare type IItemBaseConfig = Partial<{\r\n    /**\r\n     * id\r\n     */\r\n    id: string;\r\n    /**\r\n     * 类型\r\n     */\r\n    type: 'item' | 'node' | 'edge' | 'combo' | 'vedge';\r\n    /**\r\n     * data model\r\n     */\r\n    model: ModelConfig;\r\n    /**\r\n     * G Group\r\n     */\r\n    group: IGroup;\r\n    /**\r\n     * is open animate\r\n     */\r\n    animate: boolean;\r\n    /**\r\n     * visible - not group visible\r\n     */\r\n    visible: boolean;\r\n    /**\r\n     * locked - lock node\r\n     */\r\n    locked: boolean;\r\n    /**\r\n     * capture event\r\n     */\r\n    event: boolean;\r\n    /**\r\n     * key shape to calculate item's bbox\r\n     */\r\n    keyShape: IShapeBase;\r\n    /**\r\n     * item's states, such as selected or active\r\n     * @type Array\r\n     */\r\n    states: string[];\r\n    /**\r\n     * Item 的样式\r\n     */\r\n    styles: ModelStyle;\r\n    source: string | Item;\r\n    target: string | Item;\r\n    linkCenter: boolean;\r\n}> & Indexable<any>;\r\n\r\ndeclare type ILabelConfig = Partial<{\r\n    position: string;\r\n    offset: number;\r\n    refX: number;\r\n    refY: number;\r\n    autoRotate: boolean;\r\n    style: LabelStyle;\r\n}>;\r\n\r\ndeclare interface Indexable<T> {\r\n    [key: string]: T;\r\n}\r\n\r\ndeclare interface INode extends IItemBase {\r\n    /**\r\n     * 获取从节点关联的所有边\r\n     * @return {Array} 边的集合\r\n     */\r\n    getEdges(): IEdge[];\r\n    /**\r\n     * 获取引入节点的边 target == this\r\n     * @return {Array} 边的集合\r\n     */\r\n    getInEdges(): IEdge[];\r\n    /**\r\n     * 获取从节点引出的边 source == this\r\n     * @return {Array} 边的集合\r\n     */\r\n    getOutEdges(): IEdge[];\r\n    /**\r\n     * 根据锚点的索引获取连接点\r\n     * @param  {Number} index 索引\r\n     * @return {Object} 连接点 {x,y}\r\n     */\r\n    getLinkPointByAnchor(index: number): IPoint;\r\n    /**\r\n     * 获取连接点\r\n     * @param {Object} point 节点外面的一个点，用于计算交点、最近的锚点\r\n     * @return {Object} 连接点 {x,y}\r\n     */\r\n    getLinkPoint(point: IPoint): IPoint | null;\r\n    /**\r\n     * 添加边\r\n     * @param {Edge} edge 边\r\n     */\r\n    addEdge(edge: IEdge): void;\r\n    /**\r\n     * 移除边\r\n     * @param {Edge} edge 边\r\n     */\r\n    removeEdge(edge: IEdge): void;\r\n    /**\r\n     * 获取锚点的定义\r\n     * @return {array} anchorPoints， {x,y,...cfg}\r\n     */\r\n    getAnchorPoints(): IPoint[] | number[][];\r\n    hasLocked(): boolean;\r\n    lock(): void;\r\n    unlock(): void;\r\n    /**\r\n     * 获取节点所有的邻居节点\r\n     *\r\n     * @returns {INode[]}\r\n     * @memberof INode\r\n     */\r\n    getNeighbors(type?: 'source' | 'target' | undefined): INode[];\r\n}\r\n\r\ndeclare interface IPluginBaseConfig {\r\n    container?: HTMLDivElement | null;\r\n    className?: string;\r\n    graph?: Graph;\r\n    [key: string]: any;\r\n}\r\n\r\ndeclare interface IPoint {\r\n    x: number;\r\n    y: number;\r\n    anchorIndex?: number;\r\n    [key: string]: number | undefined;\r\n}\r\n\r\ndeclare interface IShapeBase extends ShapeBase {\r\n    isKeyShape: boolean;\r\n}\r\n\r\ndeclare type Item = INode | IEdge | ICombo;\r\n\r\ndeclare type ITEM_TYPE = 'node' | 'edge' | 'combo' | 'group' | 'vedge';\r\n\r\ndeclare class ItemBase implements IItemBase {\r\n    _cfg: IItemBaseConfig & {\r\n        [key: string]: unknown;\r\n    };\r\n    destroyed: boolean;\r\n    constructor(cfg: IItemBaseConfig);\r\n    /**\r\n     * 根据 keyshape 计算包围盒\r\n     */\r\n    private calculateBBox;\r\n    /**\r\n     * 根据 keyshape 计算包围盒\r\n     */\r\n    calculateCanvasBBox(): IBBox;\r\n    /**\r\n     * draw shape\r\n     */\r\n    private drawInner;\r\n    /**\r\n     * 设置图元素原始样式\r\n     * @param keyShape 图元素 keyShape\r\n     * @param group Group 容器\r\n     */\r\n    private setOriginStyle;\r\n    /**\r\n     * restore shape states\r\n     * @param shapeFactory\r\n     * @param shapeType\r\n     */\r\n    private restoreStates;\r\n    protected init(): void;\r\n    /**\r\n     * 获取属性\r\n     * @internal 仅内部类使用\r\n     * @param  {String} key 属性名\r\n     * @return {object | string | number} 属性值\r\n     */\r\n    get<T = any>(key: string): T;\r\n    /**\r\n     * 设置属性\r\n     * @internal 仅内部类使用\r\n     * @param {String|Object} key 属性名，也可以是对象\r\n     * @param {object | string | number} val 属性值\r\n     */\r\n    set(key: string | object, val?: unknown): void;\r\n    protected getDefaultCfg(): {};\r\n    /**\r\n     * 更新/刷新等操作后，清除 cache\r\n     */\r\n    protected clearCache(): void;\r\n    /**\r\n     * 渲染前的逻辑，提供给子类复写\r\n     */\r\n    protected beforeDraw(): void;\r\n    /**\r\n     * 渲染后的逻辑，提供给子类复写\r\n     */\r\n    protected afterDraw(): void;\r\n    /**\r\n     * 更新后做一些工作\r\n     */\r\n    protected afterUpdate(): void;\r\n    /**\r\n     * draw shape\r\n     */\r\n    draw(): void;\r\n    getShapeStyleByName(name?: string): ShapeStyle | void;\r\n    getShapeCfg(model: ModelConfig): ModelConfig;\r\n    /**\r\n     * 获取指定状态的样式，去除了全局样式\r\n     * @param state 状态名称\r\n     */\r\n    getStateStyle(state: string): any;\r\n    /**\r\n     * get keyshape style\r\n     */\r\n    getOriginStyle(): ShapeStyle;\r\n    getCurrentStatesStyle(): ShapeStyle;\r\n    /**\r\n     * 更改元素状态， visible 不属于这个范畴\r\n     * @internal 仅提供内部类 graph 使用\r\n     * @param {String} state 状态名\r\n     * @param {Boolean} value 节点状态值\r\n     */\r\n    setState(state: string, value: string | boolean): void;\r\n    /**\r\n     * 清除指定的状态，如果参数为空，则不做任务处理\r\n     * @param states 状态名称\r\n     */\r\n    clearStates(states?: string | string[]): void;\r\n    /**\r\n     * 节点的图形容器\r\n     * @return {G.Group} 图形容器\r\n     */\r\n    getContainer(): Group;\r\n    /**\r\n     * 节点的关键形状，用于计算节点大小，连线截距等\r\n     * @return {IShapeBase} 关键形状\r\n     */\r\n    getKeyShape(): IShapeBase;\r\n    /**\r\n     * 节点数据模型\r\n     * @return {Object} 数据模型\r\n     */\r\n    getModel(): NodeConfig | EdgeConfig | ComboConfig;\r\n    /**\r\n     * 节点类型\r\n     * @return {string} 节点的类型\r\n     */\r\n    getType(): ITEM_TYPE;\r\n    /**\r\n     * 获取 Item 的ID\r\n     */\r\n    getID(): string;\r\n    /**\r\n     * 是否是 Item 对象，悬空边情况下进行判定\r\n     */\r\n    isItem(): boolean;\r\n    /**\r\n     * 获取当前元素的所有状态\r\n     * @return {Array} 元素的所有状态\r\n     */\r\n    getStates(): string[];\r\n    /**\r\n     * 当前元素是否处于某状态\r\n     * @param {String} state 状态名\r\n     * @return {Boolean} 是否处于某状态\r\n     */\r\n    hasState(state: string): boolean;\r\n    /**\r\n     * 刷新一般用于处理几种情况\r\n     * 1. item model 在外部被改变\r\n     * 2. 边的节点位置发生改变，需要重新计算边\r\n     *\r\n     * 因为数据从外部被修改无法判断一些属性是否被修改，直接走位置和 shape 的更新\r\n     */\r\n    refresh(): void;\r\n    isOnlyMove(cfg?: ModelConfig): boolean;\r\n    /**\r\n     * 将更新应用到 model 上，刷新属性\r\n     * @internal 仅提供给 Graph 使用，外部直接调用 graph.update 接口\r\n     * @param  {Object} cfg       配置项，可以是增量信息\r\n     */\r\n    update(cfg: ModelConfig): void;\r\n    /**\r\n     * 更新元素内容，样式\r\n     */\r\n    updateShape(): void;\r\n    /**\r\n     * 更新位置，避免整体重绘\r\n     * @param {object} cfg 待更新数据\r\n     */\r\n    updatePosition(cfg: ModelConfig): void;\r\n    /**\r\n     * 获取 item 的包围盒，这个包围盒是相对于 item 自己，不会将 matrix 计算在内\r\n     * @return {Object} 包含 x,y,width,height, centerX, centerY\r\n     */\r\n    getBBox(): IBBox;\r\n    /**\r\n     * 获取 item 相对于画布的包围盒，会将从顶层到当前元素的 matrix 都计算在内\r\n     * @return {Object} 包含 x,y,width,height, centerX, centerY\r\n     */\r\n    getCanvasBBox(): IBBox;\r\n    /**\r\n     * 将元素放到最前面\r\n     */\r\n    toFront(): void;\r\n    /**\r\n     * 将元素放到最后面\r\n     */\r\n    toBack(): void;\r\n    /**\r\n     * 显示元素\r\n     */\r\n    show(): void;\r\n    /**\r\n     * 隐藏元素\r\n     */\r\n    hide(): void;\r\n    /**\r\n     * 更改是否显示\r\n     * @param  {Boolean} visible 是否显示\r\n     */\r\n    changeVisibility(visible: boolean): void;\r\n    /**\r\n     * 元素是否可见\r\n     * @return {Boolean} 返回该元素是否可见\r\n     */\r\n    isVisible(): boolean;\r\n    /**\r\n     * 是否拾取及出发该元素的交互事件\r\n     * @param {Boolean} enable 标识位\r\n     */\r\n    enableCapture(enable: boolean): void;\r\n    destroy(): void;\r\n}\r\n\r\ndeclare type LabelStyle = Partial<{\r\n    rotate: number;\r\n    textAlign: string;\r\n    angle: number;\r\n    x: number;\r\n    y: number;\r\n    text: string;\r\n    stroke: string | null;\r\n    opacity: number;\r\n    fontSize: number;\r\n    fontStyle: string;\r\n    fill: string | null;\r\n    rotateCenter: string;\r\n    lineWidth?: number;\r\n    shadowColor?: string;\r\n    shadowBlur?: number;\r\n    shadowOffsetX?: number;\r\n    shadowOffsetY?: number;\r\n    position: string;\r\n    textBaseline: string;\r\n    offset: number;\r\n    background?: {\r\n        fill?: string;\r\n        stroke?: string;\r\n        lineWidth?: number;\r\n        radius?: number[] | number;\r\n        padding?: number[] | number;\r\n    };\r\n}>;\r\n\r\ndeclare interface LayoutConfig {\r\n    type?: string;\r\n    [key: string]: unknown;\r\n}\r\n\r\ndeclare type LoopConfig = Partial<{\r\n    dist: number;\r\n    position: string;\r\n    clockwise: boolean;\r\n}>;\r\n\r\ndeclare interface ModelConfig extends ModelStyle {\r\n    shape?: string;\r\n    type?: string;\r\n    label?: string | LabelStyle;\r\n    labelCfg?: ILabelConfig;\r\n    x?: number;\r\n    y?: number;\r\n    size?: number | number[];\r\n    color?: string;\r\n    anchorPoints?: number[][];\r\n    startPoint?: {\r\n        x: number;\r\n        y: number;\r\n    };\r\n    endPoint?: {\r\n        x: number;\r\n        y: number;\r\n    };\r\n    visible?: boolean;\r\n}\r\n\r\ndeclare type ModelStyle = Partial<{\r\n    [key: string]: unknown;\r\n    style: ShapeStyle;\r\n    stateStyles: StateStyles;\r\n}>;\r\n\r\ndeclare interface ModeOption {\r\n    type: string;\r\n    delegate?: boolean;\r\n    delegateStyle?: object;\r\n    updateEdge?: boolean;\r\n    trigger?: string;\r\n    enableDelegate?: boolean;\r\n    maxZoom?: number;\r\n    minZoom?: number;\r\n    enableOptimize?: boolean;\r\n    optimizeZoom?: number;\r\n    multiple?: boolean;\r\n    activeState?: string;\r\n    comboActiveState?: string;\r\n    selectedState?: string;\r\n    onlyChangeComboSize?: boolean;\r\n    includeEdges?: boolean;\r\n    direction?: 'x' | 'y';\r\n    offset?: number;\r\n    fixSelectedItems?: Partial<{\r\n        fixAll: boolean;\r\n        fixLineWidth: boolean;\r\n        fixLabel: boolean;\r\n        fixState: string;\r\n    }>;\r\n    key?: string | undefined;\r\n    shouldUpdate?: (e: IG6GraphEvent) => boolean;\r\n    shouldBegin?: (e: IG6GraphEvent) => boolean;\r\n    shouldEnd?: (e: IG6GraphEvent) => boolean;\r\n    onChange?: (item?: Item, judge?: boolean) => unknown;\r\n    onSelect?: (selectedNodes?: Item[], selectedEdges?: Item[]) => unknown;\r\n    onDeselect?: (selectedNodes?: Item[], selectedEdges?: Item[]) => unknown;\r\n    formatText?: (data: {\r\n        [key: string]: unknown;\r\n    }) => string;\r\n}\r\n\r\ndeclare interface Modes {\r\n    default?: ModeType[];\r\n    [key: string]: ModeType[] | undefined;\r\n}\r\n\r\ndeclare type ModeType = string | ModeOption;\r\n\r\ndeclare class Node_2 extends ItemBase implements INode {\r\n    getNearestPoint(points: IPoint[], curPoint: IPoint): IPoint;\r\n    getDefaultCfg(): {\r\n        type: string;\r\n        edges: any[];\r\n    };\r\n    /**\r\n     * 获取从节点关联的所有边\r\n     */\r\n    getEdges(): IEdge[];\r\n    /**\r\n     * 获取所有的入边\r\n     */\r\n    getInEdges(): IEdge[];\r\n    /**\r\n     * 获取所有的出边\r\n     */\r\n    getOutEdges(): IEdge[];\r\n    /**\r\n     * 获取节点的邻居节点\r\n     *\r\n     * @returns {INode[]}\r\n     * @memberof Node\r\n     */\r\n    getNeighbors(type?: 'target' | 'source' | undefined): INode[];\r\n    /**\r\n     * 根据锚点的索引获取连接点\r\n     * @param  {Number} index 索引\r\n     */\r\n    getLinkPointByAnchor(index: number): IPoint;\r\n    /**\r\n     * 获取连接点\r\n     * @param point\r\n     */\r\n    getLinkPoint(point: IPoint): IPoint | null;\r\n    /**\r\n     * 获取锚点的定义\r\n     * @return {array} anchorPoints\r\n     */\r\n    getAnchorPoints(): IPoint[];\r\n    /**\r\n     * add edge\r\n     * @param edge Edge instance\r\n     */\r\n    addEdge(edge: IEdge): void;\r\n    /**\r\n     * 锁定节点\r\n     */\r\n    lock(): void;\r\n    /**\r\n     * 解锁锁定的节点\r\n     */\r\n    unlock(): void;\r\n    hasLocked(): boolean;\r\n    /**\r\n     * 移除边\r\n     * @param {Edge} edge 边\r\n     */\r\n    removeEdge(edge: IEdge): void;\r\n    clearCache(): void;\r\n    /**\r\n     * 是否仅仅移动节点，其他属性没变化\r\n     * @param cfg 节点数据模型\r\n     */\r\n    isOnlyMove(cfg: NodeConfig): boolean;\r\n}\r\n\r\ndeclare interface NodeConfig extends ModelConfig {\r\n    id: string;\r\n    groupId?: string;\r\n    comboId?: string;\r\n    children?: TreeGraphData[];\r\n    description?: string;\r\n    descriptionCfg?: {\r\n        style?: object;\r\n        [key: string]: unknown;\r\n    };\r\n    img?: string;\r\n    innerR?: number;\r\n    direction?: string;\r\n    preRect?: {\r\n        show?: boolean;\r\n        [key: string]: unknown;\r\n    };\r\n    logoIcon?: {\r\n        show?: boolean;\r\n        [key: string]: unknown;\r\n    };\r\n    stateIcon?: {\r\n        show?: boolean;\r\n        [key: string]: unknown;\r\n    };\r\n    linkPoints?: {\r\n        top?: boolean;\r\n        right?: boolean;\r\n        bottom?: boolean;\r\n        left?: boolean;\r\n        size?: number;\r\n        lineWidth?: number;\r\n        fill?: string;\r\n        stroke?: string;\r\n        r?: number;\r\n        [key: string]: unknown;\r\n    };\r\n    icon?: {\r\n        show?: boolean;\r\n        img?: string;\r\n        width?: number;\r\n        height?: number;\r\n        offset?: number;\r\n    };\r\n    clipCfg?: {\r\n        show?: boolean;\r\n        type?: string;\r\n        r?: number;\r\n        rx?: number;\r\n        ry?: number;\r\n        width?: number;\r\n        height?: number;\r\n        points?: number[][];\r\n        path?: Array<Array<string | number>>;\r\n        x?: number;\r\n        y?: number;\r\n    };\r\n}\r\n\r\ndeclare interface NodeMap {\r\n    [key: string]: INode;\r\n}\r\n\r\ndeclare type Padding = number | string | number[];\r\n\r\ndeclare abstract class PluginBase {\r\n    private _events;\r\n    _cfgs: IPluginBaseConfig;\r\n    destroyed: boolean;\r\n    /**\r\n     * 插件基类的构造函数\r\n     * @param cfgs 插件的配置项\r\n     */\r\n    constructor(cfgs?: IPluginBaseConfig);\r\n    /**\r\n     * 获取默认的插件配置\r\n     */\r\n    getDefaultCfgs(): {};\r\n    /**\r\n     * 初始化插件\r\n     * @param graph Graph 实例\r\n     */\r\n    initPlugin(graph: Graph): void;\r\n    /**\r\n     * 初始化方法，供子类实现\r\n     */\r\n    init(): void;\r\n    /**\r\n     * 获取插件中的事件和事件处理方法，供子类实现\r\n     */\r\n    getEvents(): {};\r\n    /**\r\n     * 获取配置项中的某个值\r\n     * @param key 键值\r\n     */\r\n    get(key: string): any;\r\n    /**\r\n     * 将指定的值存储到 cfgs 中\r\n     * @param key 键值\r\n     * @param val 设置的值\r\n     */\r\n    set(key: string, val: any): void;\r\n    /**\r\n     * 销毁方法，供子类复写\r\n     */\r\n    destroy(): void;\r\n    /**\r\n     * 销毁插件\r\n     */\r\n    destroyPlugin(): void;\r\n}\r\n\r\ndeclare interface PrivateGraphOption extends GraphOptions {\r\n    data: GraphData;\r\n    event: boolean;\r\n    nodes: NodeConfig[];\r\n    edges: EdgeConfig[];\r\n    vedges: EdgeConfig[];\r\n    groups: GroupConfig[];\r\n    combos: ComboConfig[];\r\n    itemMap: NodeMap;\r\n    callback: () => void;\r\n    groupBBoxs: IGroupBBox;\r\n    groupNodes: NodeMap;\r\n    /**\r\n     * 格式：\r\n     * {\r\n     *  hover: [Node, Node],\r\n     *  selected: [Node]\r\n     * }\r\n     */\r\n    states: States;\r\n}\r\n\r\ndeclare type ShapeStyle = Partial<{\r\n    x: number;\r\n    y: number;\r\n    r: number;\r\n    radius: number;\r\n    width: number;\r\n    height: number;\r\n    offset: number | number[];\r\n    stroke: string | null;\r\n    strokeOpacity: number;\r\n    fill: string | null;\r\n    fillOpacity: number;\r\n    lineWidth: number;\r\n    lineAppendWidth: number;\r\n    lineDash: number[];\r\n    path: string | object[];\r\n    points: object[];\r\n    matrix: number[];\r\n    opacity: number;\r\n    size: number | number[];\r\n    endArrow: boolean | ArrowConfig;\r\n    startArrow: boolean | ArrowConfig;\r\n    shadowColor: string;\r\n    shadowBlur: number;\r\n    shadowOffsetX: number;\r\n    shadowOffsetY: number;\r\n    cursor: string;\r\n    position: string;\r\n    fontSize: number;\r\n    keepVisualSize: boolean;\r\n}>;\r\n\r\ndeclare class Stack {\r\n    private linkedList;\r\n    private maxStep;\r\n    constructor(maxStep?: number);\r\n    get length(): number;\r\n    /**\r\n     * 判断栈是否为空，如果链表中没有头部元素，则栈为空\r\n     */\r\n    isEmpty(): boolean;\r\n    /**\r\n     * 是否到定义的栈的最大长度，如果达到最大长度后，不再允许入栈\r\n     */\r\n    isMaxStack(): boolean;\r\n    /**\r\n     * 访问顶端元素\r\n     */\r\n    peek(): any;\r\n    push(value: any): void;\r\n    pop(): any;\r\n    toArray(): any[];\r\n    clear(): void;\r\n}\r\n\r\ndeclare interface StackData {\r\n    action: string;\r\n    data: GraphData;\r\n}\r\n\r\ndeclare interface States {\r\n    [key: string]: INode[];\r\n}\r\n\r\ndeclare interface StateStyles {\r\n    [key: string]: ShapeStyle | {\r\n        [key: string]: ShapeStyle;\r\n    };\r\n}\r\n\r\ndeclare interface TreeGraphData {\r\n    id: string;\r\n    label?: string;\r\n    x?: number;\r\n    y?: number;\r\n    children?: TreeGraphData[];\r\n    data?: ModelConfig;\r\n    side?: 'left' | 'right';\r\n    depth?: number;\r\n    collapsed?: boolean;\r\n    style?: ShapeStyle | {\r\n        [key: string]: ShapeStyle;\r\n    };\r\n    stateStyles?: StateStyles;\r\n}\r\n\r\nexport { }\r\n\n        }"}}}}}